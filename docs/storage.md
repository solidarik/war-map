# Руководство по использованию MongoDb

## Доступ к серверу

Путь `uri` до сервера `mongo` передается в файле `default.js`, через переменную `mongoose.uri`. Сервер получает путь до используемого сервиса через переменную окружения `process.env.MONGODB_URI`. Если запись данных на удаленный сервер происходит из персонального компьютера, то в переменную окружения введите адрес сервера до `mongo`. Путь, логин и пароль сервиса `mongo` можно получить у администратора проекта.

## Создание новой коллекции и сохранение в базу

Предположим, мы в проекте хотим получить данные из файла persons.json, в котором находится информация о персоналиях (ФИО, заслуги, место/дата рождения/смерти). Сначала запишем информацию в `mongo`.

Используем библиотеку `mongoose`, в которой для доступа используется понятие модели/схемы. Создадим схему [personsModel.js](https://github.com/solidarik/war-map/blob/master/models/personsModel.js) в папке `models`. Схема создается на основе полей в json-источнике, и дополняется другими полями при необходимости.

Так как все данные, как правило, записаны в JSON, для их обработки написана спец. функция `dbHelper.saveFilesFrom`, принимающая в качестве аргумента структуру `input`, которая содержит источник `source` в виде папки с json-файлами или отдельный json-файл, а также папки: для записи ошибок `errdir`, и для успешно-обработанных файлов `procdir`. Каждая запись в файле обрабатывается параллельно. При этом, запись для разных типов данных, проходит через стандартизированные этапы: чтение JSON-файла, дополнение данных, подгрузка некоторых данных в случае необходимости, и запись данных в определенную структуру в БД. Так как данные разные, для каждого типа данных есть свой посредник, так называемый общий класс `SuperJsonMediator`, который предоставляет интерфейс для подклассов, каждый из которых содержит свои особенности реализации: для военных событий , для политических событий, для персоналий и т.п. Для персоналий нужен свой медиатор, поэтому создадим `personsJsonMediator.js`, скопировав файл другого медиатора. К примеру, я скопировал `chronosJsonMediator.js`, переименовав внутри chronos > persons, и скорректировав названия полей.

В конструкторе каждого медиатора определяются ключевые поля `equilFields`, которые используются для предотвращения дублирования данных. Пока определены три этапа:

- `processJson` - основной этап чтения исходного JSON-файла и сопоставление между полями файла и полям схемы/модели данных БД. В этой же функции происходит заполнение дополнительных полей: к примеру, определяются координаты из википедии для текстовых геопозиций, если в файле указано место рождения placeBirth = 'Москва', то в БД будет также заполнено поле placeBirthCoords, с координатами широты и долготы, полученной из википедии: { lon: 37.61778, lat: 55.75583 }.
- `checkJsonSync` - маркер проверки успешного чтения JSON. Для определения того, что все необходимые поля заполнены.
- `afterProcessJson` - дополнительная функция, сейчас используется для вывода диагностической информации после обработки исходного файла.

Запуск чтения JSON-файла и записи в БД можно посмотреть в файле `loadDatabase\load.js`. В нем создается экземпляр класса `dbHelper` и через цепочки промисов осуществляется очистка соответствующей коллекции в `mongo` и вызов функции обработки входного файла `saveFilesFrom` с указанием соответствующего медиатора.

Вызов `load.js` осуществляется с корневой папки проекта:
`node loadDatabase\load.js`

## Чтение данных из базы и отображение на сайте
