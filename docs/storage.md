# Руководство по использованию MongoDb

## Доступ к серверу

Путь `uri` до сервера `mongo` передается в файле [default.js](https://github.com/solidarik/war-map/blob/master/config/default.js), через переменную `mongoose.uri`. Сервер получает путь до используемого сервиса через переменную окружения `process.env.MONGODB_URI`. Если запись данных на удаленный сервер происходит из персонального компьютера, то в переменную окружения введите адрес сервера до `mongo`. Путь, логин и пароль сервиса `mongo` можно получить у администратора проекта.

## Создание новой коллекции и сохранение в базу

Предположим, мы в проекте хотим получить данные из файла persons.json, в котором находится информация о персоналиях (ФИО, заслуги, место/дата рождения/смерти). Сначала запишем информацию в `mongo`.

Используем библиотеку `mongoose`, в которой для доступа используется понятие модели/схемы. Создадим схему [personsModel.js](https://github.com/solidarik/war-map/blob/master/models/personsModel.js) в папке `models`. Схема создается на основе полей в json-источнике, и дополняется другими полями при необходимости.

Так как все данные, как правило, записаны в JSON, для их обработки написана спец. функция [dbHelper.saveFilesFrom](https://github.com/solidarik/war-map/blob/master/loadDatabase/dbHelper.js), принимающая в качестве аргумента структуру `input`, которая содержит источник `source` в виде папки с json-файлами или отдельный json-файл, а также папки: для записи ошибок `errdir`, и для успешно-обработанных файлов `procdir`. Каждая запись в файле обрабатывается параллельно. При этом, запись для разных типов данных, проходит через стандартизированные этапы: чтение JSON-файла, дополнение данных, подгрузка некоторых данных в случае необходимости, и запись данных в определенную структуру в БД. Так как данные разные, для каждого типа данных есть свой посредник, так называемый общий класс [SuperJsonMediator](https://github.com/solidarik/war-map/blob/master/loadDatabase/superJsonMediator.js), который предоставляет интерфейс для подклассов, каждый из которых содержит свои особенности реализации: для военных событий , для политических событий, для персоналий и т.п. Для персоналий нужен свой медиатор, поэтому создадим [personsJsonMediator.js](https://github.com/solidarik/war-map/blob/master/loadDatabase/personsJsonMediator.js), скопировав файл другого медиатора. К примеру, я скопировал `chronosJsonMediator.js`, переименовав внутри chronos > persons, и скорректировав названия полей.

В конструкторе каждого медиатора определяются ключевые поля `equilFields`, которые используются для предотвращения дублирования данных. Пока определены три этапа:

- `processJson` - основной этап чтения исходного JSON-файла и сопоставление между полями файла и полям схемы/модели данных БД. В этой же функции происходит заполнение дополнительных полей: к примеру, определяются координаты из википедии для текстовых геопозиций, если в файле указано место рождения placeBirth = 'Москва', то в БД будет также заполнено поле placeBirthCoords, с координатами широты и долготы, полученной из википедии: { lon: 37.61778, lat: 55.75583 }.
- `checkJsonSync` - маркер проверки успешного чтения JSON. Для определения того, что все необходимые поля заполнены.
- `afterProcessJson` - дополнительная функция, сейчас используется для вывода диагностической информации после обработки исходного файла.

Запуск чтения JSON-файла и записи в БД можно посмотреть в файле [loadDatabase\load.js](https://github.com/solidarik/war-map/blob/master/loadDatabase/load.js). В нем создается экземпляр класса `dbHelper` и через цепочки промисов осуществляется очистка соответствующей коллекции в `mongo` и вызов функции обработки входного файла `saveFilesFrom` с указанием соответствующего медиатора.

Вызов `load.js` осуществляется с корневой папки проекта:
`node loadDatabase\load.js`

## Чтение данных из базы и отображение на сайте

После сохранения данных в коллекции `persons`, рассмотрим их получение на стороне клиента.
Любой элемент проекта проектировался максимально независимо друг от друга и для их взаимодействия был выбран шаблон `Observer` (наблюдатель). Шаблон подразумевает, что у каждого компонента есть события, на которые можно подписаться и получать уведомление при их активации. К примеру, у карты есть событие выбора текущего года, или выбора определенного элемента. При этом для обмена с сервером спроектирован специальный невизуальный компонент [ClientProtocol](https://github.com/solidarik/war-map/blob/master/public-src/clientProtocol.js), который также реализует шаблон `Observer` и при этом содержит в себе методы доступа к БД сервера. Подписывание на определенные события и логика взаимодействия между компонентами задается в файле [main.js](https://github.com/solidarik/war-map/blob/master/public-src/main.js). К примеру, код

```javascript
protocol.subscribe('refreshHistoryEvents', events => {
  mapControl.setHistoryEvents(events)
  historyEventsControl.showEvents(events)
})
```

подписывается на событие `refreshHistoryEvents` у протокола, и при обновлении событий со стороны сервера выполняются две команды: передача актуальных событий компонентам "Карта" и компоненту "Список событий".

Протокол `clientProtocol` осуществляет обмен с сервером на основе веб-сокетов и библиотеки `socket.io`. При создании экземпляра протокола, он сразу инициирует обмен, отправляя на сервер запрос о получении текущего года `clGetCurrentYear`, и после получении информации генерирует событие `setCurrentYear`, предупреждая подписчиков об измении года. Карта `mapControl` после изменении года, обращается к протоколу с просьбой предоставить события за этот год. После этого, протокол, внутри себя через веб-сокеты, обращается к серверу для получения списка исторических данных. Если на стороне браузера используется один файл для общения с сервером, то на стороне сервера целый набор файлов, отнаследованные от класса [ServerProtocol](https://github.com/solidarik/war-map/blob/master/libs/serverProtocol.js). Ранее для каждой области, коллекции БД отвечал свой протокол, но в последствии протоколы стали укрупняться. Все протоколы собраны в папке [socketProtocol](https://github.com/solidarik/war-map/tree/master/socketProtocol). К примеру, функции доступа для карт собраны в файле [historyEventsProtocol](https://github.com/solidarik/war-map/blob/master/socketProtocol/historyEventsProtocol.js). Возможно, некоторые методы будут в дальнейшем перенесены в файл `mapObjectsProtocol`. Каждый дополнительный класс протокола расширяет общий протокол обмена с клиентом. Поэтому, просто добавлением нового файла, можно легко расширить выбранный протокол обмена. Отметим, что веб-сокеты также используют шаблон `Observer`.

Протокол класса включает в себя ссылку на используемую модель `mongoose` и с помощью функции БД `find` вытаскивает нужные данные из базы и передает свои результаты через callback-функцию клиенту. К примеру, для событий карт, в файле [historyEventsProtocol.js](https://github.com/solidarik/war-map/blob/master/socketProtocol/historyEventsProtocol.js) есть функция `getEventsByYear`, которая через метод find заполняет данные обо всех типах событий.

Для передачи данных о персоналиях внесем сюда поиск по созданной модели `personsModel`. (Пока не обращаем внимание на callback-hell, со временем оптимизуем через промисы.)

Теперь возвращаемся в файл протокола клиента [clientProtocol.js](https://github.com/solidarik/war-map/blob/master/public-src/clientProtocol.js) и пробрасываем полученные из базы информацию о персон и генерируем соответствующее событие (emit) для передачи данных на карту в модуль [mapControl.js](https://github.com/solidarik/war-map/blob/master/public-src/mapControl.js). Все, данные о персоналиях загружены на карту, далее пишется обработка этих событий в модуле "Карта", со стороны клиента.
